<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; background-color: #f8f8f8; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
pre, code { background-color: #f8f8f8; }
code > span.kw { color: #204a87; font-weight: bold; } /* Keyword */
code > span.dt { color: #204a87; } /* DataType */
code > span.dv { color: #0000cf; } /* DecVal */
code > span.bn { color: #0000cf; } /* BaseN */
code > span.fl { color: #0000cf; } /* Float */
code > span.ch { color: #4e9a06; } /* Char */
code > span.st { color: #4e9a06; } /* String */
code > span.co { color: #8f5902; font-style: italic; } /* Comment */
code > span.ot { color: #8f5902; } /* Other */
code > span.al { color: #ef2929; } /* Alert */
code > span.fu { color: #000000; } /* Function */
code > span.er { color: #a40000; font-weight: bold; } /* Error */
code > span.wa { color: #8f5902; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #000000; } /* Constant */
code > span.sc { color: #000000; } /* SpecialChar */
code > span.vs { color: #4e9a06; } /* VerbatimString */
code > span.ss { color: #4e9a06; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #000000; } /* Variable */
code > span.cf { color: #204a87; font-weight: bold; } /* ControlFlow */
code > span.op { color: #ce5c00; font-weight: bold; } /* Operator */
code > span.pp { color: #8f5902; font-style: italic; } /* Preprocessor */
code > span.ex { } /* Extension */
code > span.at { color: #c4a000; } /* Attribute */
code > span.do { color: #8f5902; font-weight: bold; font-style: italic; } /* Documentation */
code > span.an { color: #8f5902; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #8f5902; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #8f5902; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <link rel="stylesheet" href="pandoc.css" type="text/css" />
</head>
<body>
<h1 id="cats-effect-tutorial">Cats-effect tutorial</h1>
<h2 id="intro">Intro</h2>
<p><a href="https://typelevel.org/cats-effect">Cats-effect</a>, the effects library for <a href="https://typelevel.org/cats">Cats</a>, has a complete documentation explaining the types it brings, full with small examples about how to use them. However, even with that documentation available, it can be a bit daunting start using the library for the first time.</p>
<p>This tutorial tries to close that gap by means of coding examples. The first one it shows how we can use cats-effect to copy the contents from one file to another. That should help us to flex our muscles. The second one is a bit more complex. Step by step, we will build a light TCP server whose complexity will grow as we introduce more requirements. That growing complexity will help us to introduce more and more concepts from cats-effect.</p>
<p>That said, let's go!</p>
<h2 id="setting-things-up">Setting things up</h2>
<p>The <a href="https://github.com/lrodero/cats-effect-tutorial">Github repo for this tutorial</a> includes all the software that will be developed during this tutorial. It uses <code>sbt</code> as the build tool. To ease coding, compiling and running the code snippets in this tutorial it is recommended to use the same <code>build.sbt</code>, or at least one with the same dependencies and compilation options:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">name := <span class="st">&quot;cats-effect-tutorial&quot;</span>

version := <span class="st">&quot;1.0&quot;</span>

scalaVersion := <span class="st">&quot;2.12.2&quot;</span>

libraryDependencies += <span class="st">&quot;org.typelevel&quot;</span> %% <span class="st">&quot;cats-effect&quot;</span> % <span class="st">&quot;1.0.0&quot;</span> <span class="fu">withSources</span>() <span class="fu">withJavadoc</span>()

scalacOptions ++= Seq(
  <span class="st">&quot;-feature&quot;</span>,
  <span class="st">&quot;-deprecation&quot;</span>,
  <span class="st">&quot;-unchecked&quot;</span>,
  <span class="st">&quot;-language:postfixOps&quot;</span>,
  <span class="st">&quot;-language:higherKinds&quot;</span>,
  <span class="st">&quot;-Ypartial-unification&quot;</span>)</code></pre></div>
<h2 id="warming-up-copying-contents-of-a-file">Warming up: Copying contents of a file</h2>
<p>First we will code a function that copies the content from a file to another file. The function takes as parameters the source and destination files. But this is functional programming! So invoking the function will not copy anything, instead it will return an <code>IO</code> instance that encapsulates all the side-effects involved (opening/closing files, copying content), that way <em>purity</em> is kept. Only when that <code>IO</code> instance is evaluated all those side-effectul actions will be run. In our implementation the <code>IO</code> instance will return the amount of bytes copied upon execution, but this is just a design decission.</p>
<p>Now, the signature of our function looks like this:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">import</span> cats.<span class="fu">effect</span>.<span class="fu">IO</span>
<span class="kw">import</span> java.<span class="fu">io</span>.<span class="fu">File</span>

<span class="kw">def</span> <span class="fu">copy</span>(origin: File, destination: File): IO[Long] = ???</code></pre></div>
<p>Nothing scary, uh? As we said before, the function just returns an <code>IO</code> instance. When run, all side-effects will be actually executed and the <code>IO</code> instance will return the bytes copies in a <code>Long</code>. Note that<code>IO</code> is parameterized by the return type). Now, let's start implementing our funtion. First, we need to open two streams that will read and write file contents.</p>
<h3 id="acquiring-and-releasing-resources">Acquiring and releasing <code>Resource</code>s</h3>
<p>We consider opening an stream to be a side-effect action, so we have to encapsulate those actions in their own <code>IO</code> instances. For this, we will make use of cats-effect <code>Resource</code>, that allows to orderly create, use and then release resources. See this code:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">import</span> cats.<span class="fu">effect</span>.{IO, Resource}
<span class="kw">import</span> cats.<span class="fu">implicits</span>._ 
<span class="kw">import</span> java.<span class="fu">io</span>._ 

<span class="kw">def</span> <span class="fu">inputStream</span>(f: File): Resource[IO, FileInputStream] =
  Resource.<span class="fu">make</span> {
    <span class="fu">IO</span>(<span class="kw">new</span> FileInputStream(f))                         <span class="co">// build</span>
  } { inStream =&gt;
    <span class="fu">IO</span>(inStream.<span class="fu">close</span>()).<span class="fu">handleErrorWith</span>(_ =&gt; IO.<span class="fu">unit</span>) <span class="co">// release</span>
  }

<span class="kw">def</span> <span class="fu">outputStream</span>(f: File): Resource[IO, FileOutputStream] =
  Resource.<span class="fu">make</span> {
    <span class="fu">IO</span>(<span class="kw">new</span> FileOutputStream(f))                         <span class="co">// build </span>
  } { outStream =&gt;
    <span class="fu">IO</span>(outStream.<span class="fu">close</span>()).<span class="fu">handleErrorWith</span>(_ =&gt; IO.<span class="fu">unit</span>) <span class="co">// release</span>
  }

<span class="kw">def</span> <span class="fu">inputOutputStreams</span>(in: File, out: File): Resource[IO, (InputStream, OutputStream)] =
  <span class="kw">for</span> {
    inStream  &lt;- <span class="fu">inputStream</span>(in)
    outStream &lt;- <span class="fu">outputStream</span>(out)
  } <span class="kw">yield</span> (inStream, outStream)</code></pre></div>
<p>We want to ensure that once we are done using each stream is closed, no matter what. That is precisely why we use <code>Resource</code> in both <code>inputStream</code> and <code>outputStream</code> functions, each one returning one <code>Resource</code> that encapsulates the actions for opening and then closing each stream. <code>inputOutputStreams</code> encapsulates both resources in a single <code>Resource</code> instance that will be available once the creation has been successful. As seen in the code above <code>Resource</code> instances can be combined in for-comprehensions as they implement <code>flatMap</code>. Note also that when releasing resources we also take care of any possible error during the release itself. In this case we just 'swallow' the error, but normally it would be at least logged.</p>
<p>Optionally we could have used <code>Resource.fromAutoCloseable</code> to define our resources, that method creates <code>Resource</code> instances over objects that implement <code>java.lang.AutoCloseable</code> interface without having to define how the resource is released. So our <code>inputStream</code> function would look like this:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">import</span> cats.<span class="fu">effect</span>.{IO, Resource}
<span class="kw">import</span> java.<span class="fu">io</span>.{File, FileInputStream}

<span class="kw">def</span> <span class="fu">inputStream</span>(f: File): Resource[IO, FileInputStream] =
  Resource.<span class="fu">fromAutoCloseable</span>(<span class="fu">IO</span>(<span class="kw">new</span> FileInputStream(f)))</code></pre></div>
<p>That code is way simpler, but with that code we would not have control over what would happen if the closing operation throws an exception. Also it could be that we want to be aware when closing operations are being run, for example using logs. Those can be easily added to the release phase of a 'typical' <code>Resource</code> definition.</p>
<p>Let's go back to our <code>copy</code> function, which now looks like this:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">import</span> cats.<span class="fu">effect</span>.{IO, Resource}
<span class="kw">import</span> java.<span class="fu">io</span>._

<span class="co">// as defined before</span>
<span class="kw">def</span> <span class="fu">inputOutputStreams</span>(in: File, out: File): Resource[IO, (InputStream, OutputStream)] = ???

<span class="co">// transfer will do the real work</span>
<span class="kw">def</span> <span class="fu">transfer</span>(origin: InputStream, destination: OutputStream): IO[Long] = ???

<span class="kw">def</span> <span class="fu">copy</span>(origin: File, destination: File): IO[Long] = 
  <span class="kw">for</span> {
    count &lt;- <span class="fu">inputOutputStreams</span>(origin, destination).<span class="fu">use</span> { <span class="kw">case</span> (in, out) =&gt; 
               <span class="fu">transfer</span>(in, out)
             }
  } <span class="kw">yield</span> count</code></pre></div>
<p>The new method <code>transfer</code> will perform the actual copying of data, once the resources (the streams) are obtained. When they are not needed anymore, whatever the outcome of <code>transfer</code> (it run successfully, there was an exception...) both streams will be closed. If any of the streams could not be obtained, then <code>transfer</code> will not be run. Even better, because of <code>Resource</code> semantics, if there is any problem opening the input file then the output file will not be opened. On the other hand, if there is any issue opening the output file, then the input stream will be closed.</p>
<h3 id="what-about-bracket">What about <code>bracket</code>?</h3>
<p>Now, if you are familiar with cats-effect's <code>bracket</code> you can be wondering why we are not using it as it looks so similar to <code>Resource</code>. There are three stages when using <code>bracket</code>: <em>resource adquisition</em>, <em>usage</em>, and <em>release</em>. Each stage is defined by an <code>IO</code> instance. A fundamental property is that the <em>release</em> stage will always be run regardless whether the <em>usage</em> stage finished correctly or an exception was thrown during its execution. In our case, in the <em>adquisition</em> stage we would create the streams, then in the <em>usage</em> stage we will copy the contents, and finally in the release stage we will close the streams. Thus we could define our <code>copy</code> function as follows:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">import</span> cats.<span class="fu">effect</span>.<span class="fu">IO</span>
<span class="kw">import</span> cats.<span class="fu">implicits</span>._ 
<span class="kw">import</span> java.<span class="fu">io</span>._ 

<span class="co">// transfer will do the real work</span>
<span class="kw">def</span> <span class="fu">transfer</span>(origin: InputStream, destination: OutputStream): IO[Long] = ???

<span class="kw">def</span> <span class="fu">copy</span>(origin: File, destination: File): IO[Long] = {
  <span class="kw">val</span> inIO: IO[InputStream]  = <span class="fu">IO</span>(<span class="kw">new</span> FileInputStream(origin))
  <span class="kw">val</span> outIO:IO[OutputStream] = <span class="fu">IO</span>(<span class="kw">new</span> FileOutputStream(destination))

  (inIO, outIO)              <span class="co">// Stage 1: Getting resources </span>
    .<span class="fu">tupled</span>                  <span class="co">// From (IO[InputStream], IO[OutputStream]) to IO[(InputStream, OutputStream)]</span>
    .<span class="fu">bracket</span>{
      <span class="kw">case</span> (in, out) =&gt;
        <span class="fu">transfer</span>(in, out)    <span class="co">// Stage 2: Using resources (for copying data, in this case)</span>
    } {
      <span class="kw">case</span> (in, out) =&gt;      <span class="co">// Stage 3: Freeing resources</span>
        (<span class="fu">IO</span>(in.<span class="fu">close</span>()), <span class="fu">IO</span>(out.<span class="fu">close</span>()))
        .<span class="fu">tupled</span>              <span class="co">// From (IO[Unit], IO[Unit]) to IO[(Unit, Unit)]</span>
        .<span class="fu">handleErrorWith</span>(_ =&gt; IO.<span class="fu">unit</span>) *&gt; IO.<span class="fu">unit</span>
    }
}</code></pre></div>
<p>Code is way shorter! But there is a catch in the code above. When using <code>bracket</code>, if there is a problem when getting resources in the first stage, then the release stage will not be run. Now, in the code above first the origin file and then the destination file are opened (<code>tupled</code> just reorganizes both <code>IO</code> instances in a single one). So what would happen if we successfully open the origin file (<em>i.e.</em> when evaluating <code>inIO</code>) but then an exception is raised when opening the destination file (<em>i.e.</em> when evaluating <code>outIO</code>)? In that case the origin stream will not be closed!</p>
<p>Still, keep in mind there is a reason why <code>Resource</code> and <code>bracket</code> look so similar. In fact, <code>Resource</code> instances are using <code>bracket</code> underneath. But as commented before <code>Resource</code> allows for a more orderly handling of resources.</p>
<h3 id="copying-data">Copying data</h3>
<p>Now we do have our streams ready to go! We have to focus now on coding <code>transfer</code>. That function will have to define a loop that at each iteration reads data from the input stream into a buffer, and then writes the buffer contents into the output stream. At the same time, the loop will keep a counter of the bytes transferred. To reuse the same buffer we should define it outside the main loop, and leave the actual transmission of data to another function <code>transmit</code> that uses that loop. Something like:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">import</span> cats.<span class="fu">effect</span>.<span class="fu">IO</span>
<span class="kw">import</span> cats.<span class="fu">implicits</span>._ 
<span class="kw">import</span> java.<span class="fu">io</span>._ 

<span class="kw">def</span> <span class="fu">transmit</span>(origin: InputStream, destination: OutputStream, buffer: Array[Byte], acc: Long): IO[Long] =
  <span class="kw">for</span> {
    amount &lt;- <span class="fu">IO</span>(origin.<span class="fu">read</span>(buffer, <span class="dv">0</span>, buffer.<span class="fu">size</span>))
    count  &lt;- <span class="kw">if</span>(amount &gt; <span class="dv">-1</span>) <span class="fu">IO</span>(destination.<span class="fu">write</span>(buffer, <span class="dv">0</span>, amount)) *&gt; <span class="fu">transmit</span>(origin, destination, buffer, acc + amount)
              <span class="kw">else</span> IO.<span class="fu">pure</span>(acc) <span class="co">// End of read stream reached (by java.io.InputStream contract), nothing to write</span>
  } <span class="kw">yield</span> count <span class="co">// Returns the actual amount of bytes transmitted</span>

<span class="kw">def</span> <span class="fu">transfer</span>(origin: InputStream, destination: OutputStream): IO[Long] =
  <span class="kw">for</span> {
    buffer &lt;- <span class="fu">IO</span>(<span class="kw">new</span> Array[Byte](<span class="dv">1024</span> * <span class="dv">10</span>)) <span class="co">// Allocated only when the IO is evaluated</span>
    total  &lt;- <span class="fu">transmit</span>(origin, destination, buffer, 0L)
  } <span class="kw">yield</span> total</code></pre></div>
<p>Take a look to <code>transmit</code>, observe that both input and output actions are encapsulated in their own <code>IO</code> instances. Being <code>IO</code> a monad, we can sequence them using a for-comprehension to create another <code>IO</code>. The for-comprehension loops as long as the call to <code>read()</code> does not return a negative value, by means of recursive calls. But <code>IO</code> is stack safe, so we are not concerned about stack overflow issues. At each iteration we increase the counter <code>acc</code> with the amount of bytes read at that iteration.</p>
<p>We are making progress, and already have a version of <code>copy</code> that can be used. If any exception is raised when <code>transfer</code> is running, then the streams will be automatically closed by <code>Resource</code>. But there is something else we have to take into account: <code>IO</code> instances execution can be <strong><em>cancelled!</em></strong>. And cancellation should not be ignored, as it is a key feature of cats-effect. We will discuss cancellation in the next section.</p>
<h3 id="dealing-with-cancellation">Dealing with cancellation</h3>
<p>Cancellation is a cats-effect feature, powerful but non trivial. In cats-effect, some <code>IO</code> instances can be cancelable, meaning than their evaluation will be aborted. If the programmer is careful, an alternative <code>IO</code> task will be run under cancellation, for example to deal with potential cleaning up activities. We will see how an <code>IO</code> can be actually cancelled at the end of the <a href="#fibers-are-not-threads">Fibers are not threads! section</a>, but for now we will just keep in mind that during the execution of the <code>transfer</code> method a cancellation can occur at any time.</p>
<p>Now, <code>IO</code>s created with <code>Resource.use</code> can be cancelled. The cancellation will trigger the execution of the code that handles the closing of the resource. In our case, that would close both streams. So far so good! But what happens if cancellations happens <em>while</em> the streams are being used, <em>i.e.</em> the <code>transfer</code> method is being run? This could lead to data corruption as a stream where some thread is writting to is at the same time being closed by another thread. For more info about this problem see <a href="https://typelevel.org/cats-effect/datatypes/io.html#gotcha-cancellation-is-a-concurrent-action">Gotcha: Cancellation is a concurrent action</a> in cats-effect site.</p>
<p>To prevent such data corruption we must use some concurrency control mechanism that ensures that no stream will be closed while <code>transfer</code> is being evaluated. Cats effect provides several constructs for controlling concurrency, for this case we will use a <a href="https://typelevel.org/cats-effect/concurrency/semaphore.html"><em>semaphore</em></a>. A semaphore has a number of permits, its method <code>adquire</code> blocks if no permit is available until <code>release</code> is called on the same semaphore. We will use a semaphore with a single permit, along with a new function <code>close</code> that will close the stream, defined outside <code>copy</code> for the sake of readability:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">import</span> cats.<span class="fu">implicits</span>._
<span class="kw">import</span> cats.<span class="fu">effect</span>.{IO, Resource}
<span class="kw">import</span> cats.<span class="fu">effect</span>.<span class="fu">concurrent</span>.<span class="fu">Semaphore</span>
<span class="kw">import</span> java.<span class="fu">io</span>._
<span class="kw">import</span> scala.<span class="fu">concurrent</span>.<span class="fu">ExecutionContext</span>.<span class="fu">Implicits</span>.<span class="fu">global</span>

<span class="co">// (transfer and transmit methods are not changed)</span>
<span class="kw">def</span> <span class="fu">transfer</span>(origin: InputStream, destination: OutputStream): IO[Long] = ???

<span class="kw">def</span> <span class="fu">inputStream</span>(f: File, guard: Semaphore[IO]): Resource[IO, FileInputStream] =
  Resource.<span class="fu">make</span> {
    <span class="fu">IO</span>(<span class="kw">new</span> FileInputStream(f))
  } { inStream =&gt; 
    <span class="kw">for</span>  {
     _ &lt;- guard.<span class="fu">acquire</span>
     _ &lt;- <span class="fu">IO</span>(inStream.<span class="fu">close</span>())
     _ &lt;- guard.<span class="fu">release</span>
    } <span class="kw">yield</span> ()
  }

<span class="kw">def</span> <span class="fu">outputStream</span>(f: File, guard: Semaphore[IO]): Resource[IO, FileOutputStream] =
  Resource.<span class="fu">make</span> {
    <span class="fu">IO</span>(<span class="kw">new</span> FileOutputStream(f))
  } { outStream =&gt;
    <span class="kw">for</span>  {
     _ &lt;- guard.<span class="fu">acquire</span>
     _ &lt;- <span class="fu">IO</span>(outStream.<span class="fu">close</span>())
     _ &lt;- guard.<span class="fu">release</span>
    } <span class="kw">yield</span> ()
  }

<span class="kw">def</span> <span class="fu">inputOutputStreams</span>(in: File, out: File, guard: Semaphore[IO]): Resource[IO, (InputStream, OutputStream)] =
  <span class="kw">for</span> {
    inStream  &lt;- <span class="fu">inputStream</span>(in, guard)
    outStream &lt;- <span class="fu">outputStream</span>(out, guard)
  } <span class="kw">yield</span> (inStream, outStream)

<span class="kw">def</span> <span class="fu">copy</span>(origin: File, destination: File): IO[Long] = {
  <span class="kw">implicit</span> <span class="kw">val</span> contextShift = IO.<span class="fu">contextShift</span>(global)
  <span class="kw">for</span> {
    guard &lt;- Semaphore[IO](<span class="dv">1</span>)
    count &lt;- <span class="fu">inputOutputStreams</span>(origin, destination, guard).<span class="fu">use</span> { <span class="kw">case</span> (in, out) =&gt; 
               guard.<span class="fu">acquire</span> *&gt; <span class="fu">transfer</span>(in, out).<span class="fu">guarantee</span>(guard.<span class="fu">release</span>)
             }
  } <span class="kw">yield</span> count
}</code></pre></div>
<p>Before calling to <code>transfer</code> we acquire the semaphore, which is not released until <code>transfer</code> is done. The <code>guarantee</code> call ensures that the semaphore will be released under any circumstance, whatever the result of <code>transfer</code> (success, error, or cancellation). As the 'release' parts in the <code>Resource</code> instances are now blocked on the same semaphore, we can be sure that streams are closed only after <code>transfer</code> is over, <em>i.e.</em> we have implemented mutual exclusion of those functionalities.</p>
<p>And that is it! We are done, now we can create a program that uses this function.</p>
<h3 id="ioapp-for-our-final-program"><code>IOApp</code> for our final program</h3>
<p>We will create a program that copies files, this program only takes two parameters: the name of the origin and destination files. For coding this program we will use <code>IOApp</code> as it allows to maintain purity in our definitions up to the main function. You can check the final result <a href="https://github.com/lrodero/cats-effect-tutorial/blob/master/src/main/scala/catsEffectTutorial/CopyFile.scala">here</a>.</p>
<p><code>IOApp</code> is a kind of 'functional' equivalent to Scala's <code>App</code>, where instead of coding an effectful <code>main</code> method we code a pure <code>run</code> function. When executing the class a <code>main</code> method defined in <code>IOApp</code> will call the <code>run</code> function we have coded. Any interruption (like pressing <code>Ctrl-c</code>) will be treated as a cancellation of the running <code>IO</code>. Also <code>IOApp</code> provides an implicit execution context so it does not be imported/created by the code explicitely.</p>
<p>Also, heed in the example linked above how <code>run</code> verifies the <code>args</code> list passed. If there are less than two arguments, an error is raised. As <code>IO</code> implements <code>MonadError</code> we can at any moment call to <code>IO.raiseError</code> to interrupt a sequence of <code>IO</code> operations.</p>
<p>You can run this code from <code>sbt</code> just by issuing this call:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">&gt; runMain catsEffectTutorial.<span class="fu">CopyFile</span> origin.<span class="fu">txt</span> destination.<span class="fu">txt</span></code></pre></div>
<p>It can be argued than using <code>IO{java.nio.file.Files.copy(...)}</code> would get an <code>IO</code> with the same characteristics of purity than our function. But there is a difference: our <code>IO</code> is safely cancelable! So the user can stop the running code at any time for example by pressing <code>Ctrl-c</code>, our code will deal with safe resource release (streams closing) even under such circumstances. The same will apply if the <code>copy</code> function is run from other modules that require its functionality. If the function is cancelled while being run, still resources will be properly released.</p>
<h3 id="exercises-improving-our-small-io-program">Exercises: improving our small <code>IO</code> program</h3>
<p>To finalize we propose you some exercises that will help you to keep improving your IO-kungfu:</p>
<ol style="list-style-type: decimal">
<li>Modify the <code>IOApp</code> so it shows an error and abort the execution if the origin and destination files are the same, the origin file cannot be open for reading or the destination file cannot be opened for writing. Also, if the destination file already exists, the program should ask for confirmation before overwriting that file.</li>
<li>Modify <code>transmit</code> so the buffer size is not hardcoded but passed as parameter.</li>
<li>Use some other concurrency tool of cats-effect instead of <code>semaphore</code> to ensure mutual exclusion of <code>transfer</code> execution and streams closing.</li>
<li>Create a new program able to copy folders. If the origin folder has subfolders, then their contents must be recursively copied too. Of course the copying must be safely cancelable at any moment.</li>
</ol>
<h2 id="a-concurrent-system-with-fibers-echo-server">A concurrent system with <code>Fiber</code>s: echo server</h2>
<p>This example is a bit more complex. Here we create an echo TCP server that simply replies to each text message from a client sending back that same message. When the client sends an empty line its connection is shutdown by the server. This server will be able to attend several clients at the same time. For that we will use <code>cats-effect</code>'s <code>Fiber</code>, which can be seen as light threads. For each new client a <code>Fiber</code> instance will be spawned to serve that client.</p>
<p>We will stick to a simple design principle: <em>whoever method creates a resource is the sole responsible of dispatching it!</em>. It's worth to remark this from the beginning to better understand the code listings shown in this tutorial.</p>
<p>Let's build our server step-by-step. First we will code a method that implements the echo protocol. It will take as input the socket (<code>java.net.Socket</code> instance) that is connected to the client. The method will be basically a loop that at each iteration reads the input from the client, if the input is not an empty line then the text is sent back to the client, otherwise the method will finish.</p>
<p>The method signature will look like this:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">import</span> cats.<span class="fu">effect</span>.<span class="fu">IO</span>
<span class="kw">import</span> java.<span class="fu">net</span>.<span class="fu">Socket</span>
<span class="kw">def</span> <span class="fu">echoProtocol</span>(clientSocket: Socket): IO[Unit] = ???</code></pre></div>
<p>Reading and writing will be done using <code>java.io.BufferedReader</code> and <code>java.io.BufferedWriter</code> instances build from the socket. Recall that this method will be in charge of closing those buffers, but not the client socket (it did not create that socket after all!). We will use again <code>Resource</code> to ensure that we close the streams we create. Also, all actions with potential side-effects are encapsulated in <code>IO</code> instances. That way we ensure no side-effect is actually run until the <code>IO</code> returned by this method is evaluated. With this in mind, code looks like:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">import</span> cats.<span class="fu">effect</span>._
<span class="kw">import</span> cats.<span class="fu">implicits</span>._
<span class="kw">import</span> java.<span class="fu">io</span>._
<span class="kw">import</span> java.<span class="fu">net</span>._

<span class="kw">def</span> <span class="fu">echoProtocol</span>(clientSocket: Socket): IO[Unit] = {

  <span class="kw">def</span> <span class="fu">loop</span>(reader: BufferedReader, writer: BufferedWriter): IO[Unit] = <span class="kw">for</span> {
    line &lt;- <span class="fu">IO</span>(reader.<span class="fu">readLine</span>())
    _    &lt;- line <span class="kw">match</span> {
              <span class="kw">case</span> <span class="st">&quot;&quot;</span> =&gt; IO.<span class="fu">unit</span> <span class="co">// Empty line, we are done</span>
              <span class="kw">case</span> _  =&gt; IO{ writer.<span class="fu">write</span>(line); writer.<span class="fu">newLine</span>(); writer.<span class="fu">flush</span>() } *&gt; <span class="fu">loop</span>(reader, writer)
            }
  } <span class="kw">yield</span> ()

  <span class="kw">def</span> <span class="fu">reader</span>(clientSocket: Socket): Resource[IO, BufferedReader] =
    Resource.<span class="fu">make</span> {
      <span class="fu">IO</span>( <span class="kw">new</span> BufferedReader(<span class="kw">new</span> InputStreamReader(clientSocket.<span class="fu">getInputStream</span>())) )
    } { reader =&gt;
      <span class="fu">IO</span>(reader.<span class="fu">close</span>()).<span class="fu">handleErrorWith</span>(_ =&gt; IO.<span class="fu">unit</span>)
    }

  <span class="kw">def</span> <span class="fu">writer</span>(clientSocket: Socket): Resource[IO, BufferedWriter] =
    Resource.<span class="fu">make</span> {
      <span class="fu">IO</span>( <span class="kw">new</span> BufferedWriter(<span class="kw">new</span> PrintWriter(clientSocket.<span class="fu">getOutputStream</span>())) )
    } { writer =&gt;
      <span class="fu">IO</span>(writer.<span class="fu">close</span>()).<span class="fu">handleErrorWith</span>(_ =&gt; IO.<span class="fu">unit</span>)
    }

  <span class="kw">def</span> <span class="fu">readerWriter</span>(clientSocket: Socket): Resource[IO, (BufferedReader, BufferedWriter)] =
    <span class="kw">for</span> {
      reader &lt;- <span class="fu">reader</span>(clientSocket)
      writer &lt;- <span class="fu">writer</span>(clientSocket)
    } <span class="kw">yield</span> (reader, writer)

  <span class="fu">readerWriter</span>(clientSocket).<span class="fu">use</span> { <span class="kw">case</span> (reader, writer) =&gt;
    <span class="fu">loop</span>(reader, writer) <span class="co">// Let&#39;s get to work</span>
  }

}</code></pre></div>
<p>Note that, as we did in the previous example, we ignore possible errors when closing the streams, as there is little to do in such cases.</p>
<p>Of course, we still miss that <code>loop</code> method that will do the actual interactions with the client. It is not hard to code though:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">import</span> cats.<span class="fu">effect</span>.<span class="fu">IO</span>
<span class="kw">import</span> cats.<span class="fu">implicits</span>._
<span class="kw">import</span> java.<span class="fu">io</span>._

<span class="kw">def</span> <span class="fu">loop</span>(reader: BufferedReader, writer: BufferedWriter): IO[Unit] =
  <span class="kw">for</span> {
    line &lt;- <span class="fu">IO</span>(reader.<span class="fu">readLine</span>())
    _    &lt;- line <span class="kw">match</span> {
              <span class="kw">case</span> <span class="st">&quot;&quot;</span> =&gt; IO.<span class="fu">unit</span> <span class="co">// Empty line, we are done</span>
              <span class="kw">case</span> _  =&gt; IO{ writer.<span class="fu">write</span>(line); writer.<span class="fu">newLine</span>(); writer.<span class="fu">flush</span>() } *&gt; <span class="fu">loop</span>(reader, writer)
            }
  } <span class="kw">yield</span> ()</code></pre></div>
<p>The loop tries to read a line from the client, and if successful then it checks the line content. If empty it finishes the method, if not it sends back the line through the writer and loops back to the beginning. Easy, right :) ?</p>
<p>So we are done with our <code>echoProtocol</code> method, good! But we still miss the part of our server that will list for new connections and create fibers to attend them. Let's work on that, we implement that functionality in another method that takes as input the <code>java.io.ServerSocket</code> instance that will listen for clients:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">import</span> cats.<span class="fu">effect</span>.<span class="fu">IO</span>
<span class="kw">import</span> java.<span class="fu">net</span>.{ServerSocket, Socket}
<span class="kw">import</span> scala.<span class="fu">concurrent</span>.<span class="fu">ExecutionContext</span>.<span class="fu">Implicits</span>.<span class="fu">global</span>

<span class="co">// echoProtocol as defined before</span>
<span class="kw">def</span> <span class="fu">echoProtocol</span>(clientSocket: Socket): IO[Unit] = ???

<span class="kw">def</span> <span class="fu">serve</span>(serverSocket: ServerSocket): IO[Unit] = {
  <span class="kw">def</span> <span class="fu">close</span>(socket: Socket): IO[Unit] = 
    <span class="fu">IO</span>(socket.<span class="fu">close</span>()).<span class="fu">handleErrorWith</span>(_ =&gt; IO.<span class="fu">unit</span>)

  <span class="kw">implicit</span> <span class="kw">val</span> contextShift = IO.<span class="fu">contextShift</span>(global)
  <span class="kw">for</span> {
    socket &lt;- <span class="fu">IO</span>(serverSocket.<span class="fu">accept</span>())
    _      &lt;- <span class="fu">echoProtocol</span>(socket)
                .<span class="fu">guarantee</span>(<span class="fu">close</span>(socket)) <span class="co">// We close the socket whatever happens</span>
                .<span class="fu">start</span>                    <span class="co">// Client attended by its own Fiber!</span>
    _      &lt;- <span class="fu">serve</span>(serverSocket)         <span class="co">// Looping back to the beginning</span>
  } <span class="kw">yield</span> ()
}</code></pre></div>
<p>To be honest, that wasn't that hard either, was it? We invoke the <code>accept()</code> method of <code>ServerSocket</code> and when a new connection arrives we call the <code>echoProtocol</code> method we defined above to attend it. As client socket instances are created by this method, then it is in charge of closing them once <code>echoProtocol</code> has finished. We do this with the quite handy <code>guarantee</code> call, that ensures that when the <code>IO</code> finishes the functionality inside <code>guarantee</code> is run whatever the outcome was. In this case we ensure closing the socket, ignoring any possible error when closing. Also quite interesting: we use <code>start</code>! By doing so the <code>echoProtocol</code> call will run on its own fiber thus not blocking the main loop.</p>
<p>However let's not mix up this with Java thread <code>interrupt</code> or the like. Calling to <code>cancel</code> on a <code>Fiber</code> instance will not stop it immediately. Thing is, a <code>cancel</code> call can only have effect when an <code>IO</code> is evaluated. In this case the <code>IO</code> is blocked on <code>accept()</code>, until that call returns and the next <code>IO</code> is evaluated (next line in the for-comprehension in the code example above) cats-effect will not be able to 'abandon' the execution. So in the code above, if the fiber is waiting on <code>accept()</code> then <code>cancel()</code> would not 'unlock' the fiber. Instead the fiber will keep waiting for a connection.</p>
<p><em>NOTE: If you have coded servers before, probably you are wondering if cats-effect provides some magical way to attend an unlimited number of clients without balancing the load somehow. Truth is, it doesn't. You can spawn as many fibers as you wish, but there is no guarantee they will run simultaneously. More about this in the section <a href="#fibers-are-not-threads">Fibers are not threads!</a></em></p>
<p>So, what do we miss now? Only the creation of the server socket of course, which we can already do in the <code>run</code> method of an <code>IOApp</code>:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">import</span> cats.<span class="fu">effect</span>.{ExitCode, IO}
<span class="kw">import</span> cats.<span class="fu">implicits</span>._
<span class="kw">import</span> java.<span class="fu">net</span>.<span class="fu">ServerSocket</span>

<span class="co">/// serve as defined before</span>
<span class="kw">def</span> <span class="fu">serve</span>(serverSocket: ServerSocket): IO[Unit] = ???

<span class="kw">def</span> <span class="fu">run</span>(args: List[String]): IO[ExitCode] = {

  <span class="kw">def</span> <span class="fu">close</span>(socket: ServerSocket): IO[Unit] =
    <span class="fu">IO</span>(socket.<span class="fu">close</span>()).<span class="fu">handleErrorWith</span>(_ =&gt; IO.<span class="fu">unit</span>)

  <span class="fu">IO</span>( <span class="kw">new</span> ServerSocket(args.<span class="fu">headOption</span>.<span class="fu">map</span>(_.<span class="fu">toInt</span>).<span class="fu">getOrElse</span>(<span class="dv">5432</span>)) )
    .<span class="fu">bracket</span>{
      serverSocket =&gt; <span class="fu">serve</span>(serverSocket) *&gt; IO.<span class="fu">pure</span>(ExitCode.<span class="fu">Success</span>)
    } {
      serverSocket =&gt; <span class="fu">close</span>(serverSocket) *&gt; <span class="fu">IO</span>(<span class="fu">println</span>(<span class="st">&quot;Server finished&quot;</span>))
    }
}</code></pre></div>
<p>Our server now looks <a href="https://github.com/lrodero/cats-effect-tutorial/blob/master/src/main/scala/catsEffectTutorial/EchoServerV1_Simple.scala">like this</a>.</p>
<p>As before you can run in for example from the <code>sbt</code> console just by typing</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">&gt; runMain catsEffectTutorial.<span class="fu">EchoServerV1_Simple</span></code></pre></div>
<p>That will start the server on default port <code>5432</code>, you can also set any other port by passing it as argument. To test the server is properly running, you can connect to it using <code>telnet</code>. Here we connect, send <code>hi</code>, and the server replies with the same text. Finally we send an empty line to close the connection:</p>
<pre class="console"><code>$ telnet localhost 5432
Trying 127.0.0.1...
Connected to localhost.
Escape character is &#39;^]&#39;.
hi
hi

Connection closed by foreign host.</code></pre>
<p>You can connect several telnet sessions at the same time to verify that indeed our server can attend all of them simultaneously.</p>
<p>Unfortunately this server is a bit too simplistic. For example, how can we stop it? Well, that is something we have not addressed yet and it is when things can get a bit more complicated. We will deal with proper server halting in the next section.</p>
<h2 id="graceful-server-stop-handling-exit-events">Graceful server stop (handling exit events)</h2>
<p>There is no way to shutdown gracefully the echo server coded in the previous version. Sure we can always <code>Ctrl-c</code> it, but proper servers should provide better mechanisms to stop them. In this section we use some other <code>cats-effect</code> constructs to deal with this.</p>
<p>First, we will use a flag to signal when the server shall quit. The server will run on its own fiber, that will be cancelled when that flag is set. The flag will be an instance of <code>MVar</code>. The <code>cats-effect</code> documentation describes <code>MVar</code> as <em>a mutable location that can be empty or contains a value, asynchronously blocking reads when empty and blocking writes when full</em>. That is what we need, the ability to block! So we will 'block' by reading our <code>MVar</code> instance, and only writing when <code>STOP</code> is received, the write being the <em>signal</em> that the server must be shut down. The server will be only stopped once, so we are not concerned about blocking on writing. Another possible choice would be using <code>cats-effect</code>'s <code>Deferred</code>, but unlike <code>Deferred</code> <code>MVar</code> does allow to peek whether a value was written or not. As we shall see, this will come handy later on.</p>
<p>And who shall signal that the server must be stopped? In this example, we will assume that it will be the connected users who can request the server to halt by sendind a <code>STOP</code> message. Thus, the method attending clients (<code>echoProtocol</code>!) needs access to the flag.</p>
<p>Let's first define a new method <code>server</code> that instantiates the flag, runs the <code>serve</code> method in its own fiber and waits on the flag to be set. Only when the flag is set the server fiber will be cancelled.</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">import</span> cats.<span class="fu">effect</span>.{ExitCode, IO}
<span class="kw">import</span> cats.<span class="fu">effect</span>.<span class="fu">concurrent</span>.<span class="fu">MVar</span>
<span class="kw">import</span> java.<span class="fu">net</span>.<span class="fu">ServerSocket</span>
<span class="kw">import</span> scala.<span class="fu">concurrent</span>.<span class="fu">ExecutionContext</span>.<span class="fu">Implicits</span>.<span class="fu">global</span>

<span class="co">// serve now requires access to the stopFlag, it will use it to signal the</span>
<span class="co">// server must stop</span>
<span class="kw">def</span> <span class="fu">serve</span>(serverSocket: ServerSocket, stopFlag: MVar[IO, Unit]): IO[Unit] = ???

<span class="kw">def</span> <span class="fu">server</span>(serverSocket: ServerSocket): IO[ExitCode] = {
  <span class="kw">implicit</span> <span class="kw">val</span> contextShift = IO.<span class="fu">contextShift</span>(global)
  <span class="kw">for</span> {
      stopFlag    &lt;- MVar[IO].<span class="fu">empty</span>[Unit]
      serverFiber &lt;- <span class="fu">serve</span>(serverSocket, stopFlag).<span class="fu">start</span> <span class="co">// Server runs on its own Fiber</span>
      _           &lt;- stopFlag.<span class="fu">read</span>                       <span class="co">// Blocked until &#39;stopFlag.put(())&#39; is run</span>
      _           &lt;- serverFiber.<span class="fu">cancel</span>                  <span class="co">// Stopping server!</span>
  } <span class="kw">yield</span> ExitCode.<span class="fu">Success</span>
}</code></pre></div>
<p>The code above requires a <code>contextShift</code> in scope to compile. In the final version our server will run inside an <code>IOApp</code> and it will not be necessary to pass it explicitly, <code>IOApp</code> will take care of that.</p>
<p>We must also modify the main <code>run</code> method in <code>IOApp</code> so now it calls to <code>server</code>:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">import</span> cats.<span class="fu">effect</span>._
<span class="kw">import</span> cats.<span class="fu">implicits</span>._
<span class="kw">import</span> java.<span class="fu">net</span>.<span class="fu">ServerSocket</span>

<span class="co">// server as defined before</span>
<span class="kw">def</span> <span class="fu">server</span>(serverSocket: ServerSocket): IO[ExitCode] = ???

<span class="kw">def</span> <span class="fu">run</span>(args: List[String]): IO[ExitCode] = {

  <span class="kw">def</span> <span class="fu">close</span>(socket: ServerSocket): IO[Unit] =
    <span class="fu">IO</span>(socket.<span class="fu">close</span>()).<span class="fu">handleErrorWith</span>(_ =&gt; IO.<span class="fu">unit</span>)

  IO{ <span class="kw">new</span> ServerSocket(args.<span class="fu">headOption</span>.<span class="fu">map</span>(_.<span class="fu">toInt</span>).<span class="fu">getOrElse</span>(<span class="dv">5432</span>)) }
    .<span class="fu">bracket</span>{
      serverSocket =&gt; <span class="fu">server</span>(serverSocket) *&gt; IO.<span class="fu">pure</span>(ExitCode.<span class="fu">Success</span>)
    } {
      serverSocket =&gt; <span class="fu">close</span>(serverSocket)  *&gt; <span class="fu">IO</span>(<span class="fu">println</span>(<span class="st">&quot;Server finished&quot;</span>))
    }
}</code></pre></div>
<p>So <code>run</code> calls <code>server</code> which in turn calls <code>serve</code>. Do we need to modify <code>serve</code> as well? Yes, for two reasons:</p>
<ol style="list-style-type: decimal">
<li>We need to pass the <code>stopFlag</code> to the <code>echoProtocol</code> method.</li>
<li>When the <code>server</code> method returns the <code>run</code> method will close the server socket. That will cause the <code>serverSocket.accept()</code> in <code>serve</code> to throw an exception. We could handle it as any other exception... but that would show an error message in console, while in fact this is a 'controlled' shutdown. So we should instead control what caused the exception.</li>
</ol>
<p>This is how we implement <code>serve</code> now:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">import</span> cats.<span class="fu">effect</span>.<span class="fu">IO</span>
<span class="kw">import</span> cats.<span class="fu">effect</span>.<span class="fu">concurrent</span>.<span class="fu">MVar</span>
<span class="kw">import</span> cats.<span class="fu">implicits</span>._
<span class="kw">import</span> java.<span class="fu">net</span>._
<span class="kw">import</span> scala.<span class="fu">concurrent</span>.<span class="fu">ExecutionContext</span>.<span class="fu">Implicits</span>.<span class="fu">global</span>

<span class="co">// echoProtocol now requires access to the stopFlag, it will use it to signal the</span>
<span class="co">// server must stop</span>
<span class="kw">def</span> <span class="fu">echoProtocol</span>(clientSocket: Socket, stopFlag: MVar[IO, Unit]): IO[Unit] = ???

<span class="kw">def</span> <span class="fu">serve</span>(serverSocket: ServerSocket, stopFlag: MVar[IO, Unit]): IO[Unit] = {

  <span class="kw">def</span> <span class="fu">close</span>(socket: Socket): IO[Unit] = 
    <span class="fu">IO</span>(socket.<span class="fu">close</span>()).<span class="fu">handleErrorWith</span>(_ =&gt; IO.<span class="fu">unit</span>)

  <span class="kw">implicit</span> <span class="kw">val</span> contextShift = IO.<span class="fu">contextShift</span>(global)
  <span class="kw">for</span> {
    socketE &lt;- <span class="fu">IO</span>(serverSocket.<span class="fu">accept</span>()).<span class="fu">attempt</span>
    _       &lt;- socketE <span class="kw">match</span> {
      <span class="kw">case</span> <span class="fu">Right</span>(socket) =&gt;
        <span class="kw">for</span> { <span class="co">// accept() succeeded, we attend the client in its own Fiber</span>
          _ &lt;- <span class="fu">echoProtocol</span>(socket, stopFlag)
                 .<span class="fu">guarantee</span>(<span class="fu">close</span>(socket))   <span class="co">// We close the server whatever happens</span>
                 .<span class="fu">start</span>                      <span class="co">// Client attended by its own Fiber</span>
          _ &lt;- <span class="fu">serve</span>(serverSocket, stopFlag) <span class="co">// Looping back to the beginning</span>
        } <span class="kw">yield</span> ()
      <span class="kw">case</span> <span class="fu">Left</span>(e) =&gt;
        <span class="kw">for</span> { <span class="co">// accept() failed, stopFlag will tell us whether this is a graceful shutdown</span>
          isEmpty &lt;- stopFlag.<span class="fu">isEmpty</span>
          _       &lt;- <span class="kw">if</span>(!isEmpty) IO.<span class="fu">unit</span>    <span class="co">// stopFlag is set, nothing to do</span>
                     <span class="kw">else</span> IO.<span class="fu">raiseError</span>(e)   <span class="co">// stopFlag not set, must raise error</span>
        } <span class="kw">yield</span> ()
    }
  } <span class="kw">yield</span> ()
}</code></pre></div>
<p>This new implementation of <code>serve</code> does not just call <code>accept()</code> inside an <code>IO</code>. It also uses <code>attempt</code>, which returns an instance of <code>Either</code> (<code>Either[Throwable, Socket]</code> in this case). We can then check the value of that <code>Either</code> to verify if the <code>accept()</code> call was successful, and in case of error deciding what to do depending on whether the <code>stopFlag</code> is set or not. If it is set then we assume that the socket was closed due to normal cancellation (<em>i.e.</em> <code>server</code> called <code>cancel</code> on the fiber running <code>serve</code>). If not the error is promoted using <code>IO.raiseError</code>, which will also quit the current <code>IO</code> execution.</p>
<p>There is only one step missing, modifying <code>echoProtocol</code>. In fact, the only relevant changes are on its inner <code>loop</code> method. Now it will check whether the line received from the client is &quot;<code>STOP</code>&quot;, if so it will set the <code>stopFlag</code> to signal the server must be stopped, and the function will quit:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">import</span> cats.<span class="fu">effect</span>.<span class="fu">IO</span>
<span class="kw">import</span> cats.<span class="fu">effect</span>.<span class="fu">concurrent</span>.<span class="fu">MVar</span>
<span class="kw">import</span> cats.<span class="fu">implicits</span>._
<span class="kw">import</span> java.<span class="fu">io</span>._

<span class="kw">def</span> <span class="fu">loop</span>(reader: BufferedReader, writer: BufferedWriter, stopFlag: MVar[IO, Unit]): IO[Unit] =
  <span class="kw">for</span> {
    line &lt;- <span class="fu">IO</span>(reader.<span class="fu">readLine</span>())
    _    &lt;- line <span class="kw">match</span> {
              <span class="kw">case</span> <span class="st">&quot;STOP&quot;</span> =&gt; stopFlag.<span class="fu">put</span>(()) <span class="co">// Stopping server! Also put(()) returns IO[Unit] which is handy as we are done</span>
              <span class="kw">case</span> <span class="st">&quot;&quot;</span>     =&gt; IO.<span class="fu">unit</span>          <span class="co">// Empty line, we are done</span>
              <span class="kw">case</span> _      =&gt; IO{ writer.<span class="fu">write</span>(line); writer.<span class="fu">newLine</span>(); writer.<span class="fu">flush</span>() } *&gt; <span class="fu">loop</span>(reader, writer, stopFlag)
            }
  } <span class="kw">yield</span> ()</code></pre></div>
<p>Code now looks <a href="https://github.com/lrodero/cats-effect-tutorial/blob/master/src/main/scala/catsEffectTutorial/EchoServerV2_GracefulStop.scala">like this</a>.</p>
<p>If you run the server coded above, open a telnet session against it and send an <code>STOP</code> message you will see how the server finishes properly.</p>
<p>But there is a catch yet. If there are several clients connected, sending an <code>STOP</code> message will close the server's fiber and the one attending the client that sent the message. But the other fibers will keep running normally! It is like they were daemon threads. Arguably, we could expect that shutting down the server shall close <em>all</em> connections. How could we do it? Solving that issue is the proposed final exercise below.</p>
<h3 id="exercise-closing-client-connections-to-echo-server-on-shutdown">Exercise: closing client connections to echo server on shutdown</h3>
<p>We need to close all connections with clients when the server is shut down. To do that we can call <code>cancel</code> on each one of the <code>Fiber</code> instances we have created to attend each new client. But how? After all, we are not tracking which fibers are running at any given time. We propose this exercise to you: can you devise a mechanism so all client connections are closed when the server is shutdown? We propose a solution in the next subsection, but maybe you can consider taking some time looking for a solution yourself :) .</p>
<h3 id="solution">Solution</h3>
<p>We could keep a list of active fibers serving client connections. It is doable, but cumbersome... and not really needed at this point.</p>
<p>Think about it: we have a <code>stopFlag</code> that signals when the server must be stopped. When that flag is set we can assume we shall close all client connections too. Thus what we need to do is, every time we create a new fiber to attend some new client, we must also make sure that when <code>stopFlag</code> is set that client is 'shutdown'. As <code>Fiber</code> instances are very light we can create a new instance just to wait for <code>stopFlag.read</code> and then forcing the client to stop. This is how the <code>serve</code> method will look like now with that change:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">import</span> cats.<span class="fu">effect</span>.<span class="fu">IO</span>
<span class="kw">import</span> cats.<span class="fu">effect</span>.<span class="fu">concurrent</span>.<span class="fu">MVar</span>
<span class="kw">import</span> cats.<span class="fu">implicits</span>._
<span class="kw">import</span> java.<span class="fu">net</span>._
<span class="kw">import</span> scala.<span class="fu">concurrent</span>.<span class="fu">ExecutionContext</span>.<span class="fu">Implicits</span>.<span class="fu">global</span>

<span class="kw">def</span> <span class="fu">echoProtocol</span>(clientSocket: Socket, stopFlag: MVar[IO, Unit]): IO[Unit] = ???

<span class="kw">def</span> <span class="fu">serve</span>(serverSocket: ServerSocket, stopFlag: MVar[IO, Unit]): IO[Unit] = {

  <span class="kw">def</span> <span class="fu">close</span>(socket: Socket): IO[Unit] = 
    <span class="fu">IO</span>(socket.<span class="fu">close</span>()).<span class="fu">handleErrorWith</span>(_ =&gt; IO.<span class="fu">unit</span>)

  <span class="kw">implicit</span> <span class="kw">val</span> contextShift = IO.<span class="fu">contextShift</span>(global)
  <span class="kw">for</span> {
    socketE &lt;- <span class="fu">IO</span>(serverSocket.<span class="fu">accept</span>()).<span class="fu">attempt</span>
    _       &lt;- socketE <span class="kw">match</span> {
      <span class="kw">case</span> <span class="fu">Right</span>(socket) =&gt;
        <span class="kw">for</span> { <span class="co">// accept() succeeded, we attend the client in its own Fiber</span>
          fiber &lt;- <span class="fu">echoProtocol</span>(socket, stopFlag)
                     .<span class="fu">guarantee</span>(<span class="fu">close</span>(socket))      <span class="co">// We close the server whatever happens</span>
                     .<span class="fu">start</span>                         <span class="co">// Client attended by its own Fiber</span>
          _     &lt;- (stopFlag.<span class="fu">read</span> *&gt; <span class="fu">close</span>(socket)) 
                     .<span class="fu">start</span>                         <span class="co">// Another Fiber to cancel the client when stopFlag is set</span>
          _     &lt;- <span class="fu">serve</span>(serverSocket, stopFlag)    <span class="co">// Looping to wait for the next client connection</span>
        } <span class="kw">yield</span> ()
      <span class="kw">case</span> <span class="fu">Left</span>(e) =&gt;
        <span class="kw">for</span> { <span class="co">// accept() failed, stopFlag will tell us whether this is a graceful shutdown</span>
          isEmpty &lt;- stopFlag.<span class="fu">isEmpty</span>
          _       &lt;- <span class="kw">if</span>(!isEmpty) IO.<span class="fu">unit</span>  <span class="co">// stopFlag is set, cool, we are done</span>
                     <span class="kw">else</span> IO.<span class="fu">raiseError</span>(e) <span class="co">// stopFlag not set, must raise error</span>
        } <span class="kw">yield</span> ()
    }
  } <span class="kw">yield</span> ()
}</code></pre></div>
<p>Now you may think '<em>wait a minute!, why don't cancelling the client fiber instead of closing the socket straight away?</em>'. Well, cancellation will not have effect until some new <code>IO</code> instance is evaluated. Normally the loop will be blocked on the <code>IO</code> instance that contains the <code>reader.readLine()</code> call. Until that <code>IO</code> operation is done the cancellation will not take effect. But then again, we want the connection to the client to be closed right away. To force the termination even when the reader is waiting for input data we close the client socket. That will raise an exception in the <code>reader.readLine()</code> line. As it happened before with the server socket, that exception will be shown as an ugly error message in the console. To prevent this we modify the <code>loop</code> function so it uses <code>attempt</code> to control possible errors. If some error is detected first the state of <code>stopFlag</code> is checked, and if it is set a graceful shutdown is assumed and no action is taken; otherwise the error is raised:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">import</span> cats.<span class="fu">effect</span>.<span class="fu">IO</span>
<span class="kw">import</span> cats.<span class="fu">effect</span>.<span class="fu">concurrent</span>.<span class="fu">MVar</span>
<span class="kw">import</span> cats.<span class="fu">implicits</span>._
<span class="kw">import</span> java.<span class="fu">io</span>._

<span class="kw">def</span> <span class="fu">loop</span>(reader: BufferedReader, writer: BufferedWriter, stopFlag: MVar[IO, Unit]): IO[Unit] =
  <span class="kw">for</span> {
    lineE &lt;- <span class="fu">IO</span>(reader.<span class="fu">readLine</span>()).<span class="fu">attempt</span>
    _     &lt;- lineE <span class="kw">match</span> {
               <span class="kw">case</span> <span class="fu">Right</span>(line) =&gt; line <span class="kw">match</span> {
                 <span class="kw">case</span> <span class="st">&quot;STOP&quot;</span> =&gt; stopFlag.<span class="fu">put</span>(()) <span class="co">// Stopping server! Also put(()) returns IO[Unit] which is handy as we are done</span>
                 <span class="kw">case</span> <span class="st">&quot;&quot;</span>     =&gt; IO.<span class="fu">unit</span>          <span class="co">// Empty line, we are done</span>
                 <span class="kw">case</span> _      =&gt; IO{ writer.<span class="fu">write</span>(line); writer.<span class="fu">newLine</span>(); writer.<span class="fu">flush</span>() } *&gt; <span class="fu">loop</span>(reader, writer, stopFlag)
               }
               <span class="kw">case</span> <span class="fu">Left</span>(e) =&gt;
                 <span class="kw">for</span> { <span class="co">// readLine() failed, stopFlag will tell us whether this is a graceful shutdown</span>
                   isEmpty &lt;- stopFlag.<span class="fu">isEmpty</span>
                   _       &lt;- <span class="kw">if</span>(!isEmpty) IO.<span class="fu">unit</span>  <span class="co">// stopFlag is set, cool, we are done</span>
                              <span class="kw">else</span> IO.<span class="fu">raiseError</span>(e) <span class="co">// stopFlag not set, must raise error</span>
                 } <span class="kw">yield</span> ()
             }
  } <span class="kw">yield</span> ()</code></pre></div>
<p>The resulting server code is <a href="https://github.com/lrodero/cats-effect-tutorial/blob/master/src/main/scala/catsEffectTutorial/EchoServerV3_ClosingClientsOnShutdown">also available</a>.</p>
<h2 id="fibers-are-not-threads"><code>Fiber</code>s are not threads!<a name="fibers-are-not-threads"></a></h2>
<p>As stated before, fibers are like 'light' threads, meaning they can be used in a similar way than threads to create concurrent code. However, they are <em>not</em> threads. Spawning new fibers does not guarantee that the action described in the <code>IO</code> associated to it will be run... immediately. At the end of the day, if no thread is available that can run the fiber, then the actions in that fiber will be blocked until some thread is available.</p>
<p>You can test this yourself. Start the server defined in the previous sections and try to connect several clients and send lines to the server through them. Soon you will notice that the latest clients... do not get any echo reply when sending lines! Why is that? Well, the answer is that the first fibers already used all <em>underlying</em> threads available! But if we close one of the active clients by sending an empty line (recall that makes the server to close that client session) then immediately one of the blocked clients will be active.</p>
<p>It shall be clear from that experiment than fibers are run by thread pools. And that in our case, all our fibers share the same thread pool! Which one in our case? Well, <code>IOApp</code> automatically brings a <code>Timer[IO]</code>, that is defined by cats-effect as a '<em>functional equivalente of Java's <a href="https://docs.oracle.com/javase/9/docs/api/java/util/concurrent/ScheduledExecutorService.html">ScheduledExecutorService</a></em>'. Each executor service has an underlying thread pool to execute the commands it is requested, and the same applies to <code>Timer</code>, which is in charge of assigning available threads to the pending <code>IO</code> actions. So there are our threads!</p>
<p>Cats-effect provides ways to use different <code>scala.concurrent.ExecutionContext</code>s, each one with its own thread pool, and to swap which one should be used for each new <code>IO</code> to ask to reschedule threads among the current active <code>IO</code> instances <em>e.g.</em> for improved fairness etc. Such functionality is provided by <code>IO.shift</code>. Also, it even allows to 'swap' to different <code>Timer</code>s (that is, different thread pools) when running <code>IO</code> actions. See this code, which is mostly a copy example available at <a href="https://typelevel.org/cats-effect/datatypes/io.html#thread-shifting">IO documentation in cats-effect web, Thread Shifting section</a>:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">import</span> cats.<span class="fu">effect</span>.<span class="fu">IO</span>
<span class="kw">import</span> java.<span class="fu">util</span>.<span class="fu">concurrent</span>.<span class="fu">Executors</span>
<span class="kw">import</span> scala.<span class="fu">concurrent</span>.<span class="fu">ExecutionContext</span>
<span class="kw">import</span> scala.<span class="fu">concurrent</span>.<span class="fu">ExecutionContext</span>.<span class="fu">Implicits</span>.<span class="fu">global</span>

<span class="kw">val</span> cachedThreadPool = Executors.<span class="fu">newCachedThreadPool</span>()
<span class="kw">val</span> clientsExecutionContext = ExecutionContext.<span class="fu">fromExecutor</span>(cachedThreadPool)
<span class="kw">implicit</span> <span class="kw">val</span> contextShift = IO.<span class="fu">contextShift</span>(global) 

<span class="kw">for</span> {
  _ &lt;- IO.<span class="fu">shift</span>(clientsExecutionContext) <span class="co">// Swapping to cached thread pool</span>
  _ &lt;- <span class="fu">IO</span>(???) <span class="co">// Whatever is done here, is done by a thread from the cached thread pool</span>
  _ &lt;- IO.<span class="fu">shift</span> <span class="co">// Swapping back to default timer</span>
  _ &lt;- <span class="fu">IO</span>(<span class="fu">println</span>(s<span class="st">&quot;Welcome!&quot;</span>)) 
} <span class="kw">yield</span> ()</code></pre></div>
<p><code>IO.shift</code> is a powerful tool but can be a bit confusing to beginners (and even intermediate) users of cats-effect. So do not worry if it takes some time for you to master.</p>
<h3 id="exercise-using-a-custom-thread-pool-in-echo-server">Exercise: using a custom thread pool in echo server</h3>
<p>Given what we know so far, how could we solve the problem of the limited number of clients attended in parallel in our echo server? Recall that in traditional servers we would make use of an specific thread pool for clients, able to resize in case more threads are needed. You can get such a pool using <code>Executors.newCachedThreadPool()</code> as in the example of the previous section. But take care of shutting it down when the server is stopped!</p>
<h3 id="solution-1">Solution</h3>
<p>Well, the solution is quite straighforward. We only need to create a thread pool and execution context, and use it whenever we need to read input from some connected client. So the beginning of the <code>loop</code> function would look like:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">for</span>{
  _     &lt;- IO.<span class="fu">shift</span>(clientsExecutionContext)
  lineE &lt;- <span class="fu">IO</span>(reader.<span class="fu">readLine</span>()).<span class="fu">attempt</span>
  _     &lt;- IO.<span class="fu">shift</span>(ExecutionContext.<span class="fu">global</span>)
  <span class="co">//</span></code></pre></div>
<p>and... that is mostly it. Only pending change is to create the thread pool and execution context in the <code>server</code> function, which will be in charge also of shutting down the thread pool when the server finishes:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">import</span> cats.<span class="fu">effect</span>._
<span class="kw">import</span> cats.<span class="fu">effect</span>.<span class="fu">concurrent</span>.<span class="fu">MVar</span>
<span class="kw">import</span> cats.<span class="fu">implicits</span>._
<span class="kw">import</span> java.<span class="fu">net</span>.<span class="fu">ServerSocket</span>
<span class="kw">import</span> java.<span class="fu">util</span>.<span class="fu">concurrent</span>.<span class="fu">Executors</span>
<span class="kw">import</span> scala.<span class="fu">concurrent</span>.<span class="fu">ExecutionContext</span>
<span class="kw">import</span> scala.<span class="fu">concurrent</span>.<span class="fu">ExecutionContext</span>.<span class="fu">Implicits</span>.<span class="fu">global</span>

<span class="kw">def</span> <span class="fu">serve</span>(serverSocket: ServerSocket, stopFlag: MVar[IO, Unit])(<span class="kw">implicit</span> clientsExecutionContext: ExecutionContext): IO[Unit] = ???

<span class="kw">def</span> <span class="fu">server</span>(serverSocket: ServerSocket): IO[ExitCode] = {

  <span class="kw">val</span> clientsThreadPool = Executors.<span class="fu">newCachedThreadPool</span>()
  <span class="kw">implicit</span> <span class="kw">val</span> clientsExecutionContext = ExecutionContext.<span class="fu">fromExecutor</span>(clientsThreadPool)
  <span class="kw">implicit</span> <span class="kw">val</span> contextShift = IO.<span class="fu">contextShift</span>(global)

  <span class="kw">for</span> {
    stopFlag     &lt;- MVar[IO].<span class="fu">empty</span>[Unit]
    serverFiber  &lt;- <span class="fu">serve</span>(serverSocket, stopFlag).<span class="fu">start</span>
    _            &lt;- stopFlag.<span class="fu">read</span> *&gt; IO{<span class="fu">println</span>(s<span class="st">&quot;Stopping server&quot;</span>)}
    _            &lt;- IO{clientsThreadPool.<span class="fu">shutdown</span>()}
    _            &lt;- serverFiber.<span class="fu">cancel</span>
  } <span class="kw">yield</span> ExitCode.<span class="fu">Success</span>

}</code></pre></div>
<p>Signatures of <code>serve</code> and of <code>echoProtocol</code> will have to be changed too to pass the execution context as parameter. The resulting server code is <a href="https://github.com/lrodero/cats-effect-tutorial/blob/master/src/main/scala/catsEffectTutorial/EchoServerV4_ClientThreadPool">available in github</a>.</p>
<h2 id="lets-not-forget-about-async">Let's not forget about <code>async</code></h2>
<p>The <code>async</code> functionality is another powerful capability of cats-effect we have not mentioned yet. It allows to build <code>IO</code> instances that may be terminated by a thread different than the one carrying the evaluation of that instance. Result will be returned by using a callback.</p>
<p>Some of you may wonder if that could help us to solve the issue of having blocking code in our fabolous echo server. Unfortunately, <code>async</code> cannot magically 'unblock' such code. Try this simple code snippet:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">import</span> cats.<span class="fu">effect</span>.<span class="fu">IO</span>
<span class="kw">import</span> cats.<span class="fu">implicits</span>._
<span class="kw">import</span> scala.<span class="fu">util</span>.<span class="fu">Either</span>

<span class="kw">val</span> delayedIO = <span class="kw">for</span> {
  _ &lt;- <span class="fu">IO</span>(<span class="fu">println</span>(<span class="st">&quot;Starting&quot;</span>))
  _ &lt;- IO.<span class="fu">async</span>[Unit]{ (cb: Either[Throwable,Unit] =&gt; Unit) =&gt;
      Thread.<span class="fu">sleep</span>(<span class="dv">2000</span>)
      <span class="fu">cb</span>(<span class="fu">Right</span>(()))
    }
  _ &lt;- <span class="fu">IO</span>(<span class="fu">println</span>(<span class="st">&quot;Done&quot;</span>)) <span class="co">// 2 seconds to get here, no matter what</span>
} <span class="kw">yield</span>()

delayedIO.<span class="fu">unsafeRunSync</span>()</code></pre></div>
<p>You will notice that the code still blocks. So how is <code>async</code> useful? Well, because it allows a different thread to finish the task, we can modify the blocking read call inside the <code>loop</code> function of our server with something like:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">for</span> {
  lineE &lt;- IO.<span class="fu">async</span>{ (cb: Either[Throwable, Either[Throwable, String]] =&gt; Unit) =&gt; 
             clientsExecutionContext.<span class="fu">execute</span>(<span class="kw">new</span> Runnable {
               <span class="kw">override</span> <span class="kw">def</span> <span class="fu">run</span>(): Unit = {
                 <span class="kw">val</span> result: Either[Throwable, String] = <span class="fu">Try</span>(reader.<span class="fu">readLine</span>()).<span class="fu">toEither</span>
                 <span class="fu">cb</span>(<span class="fu">Right</span>(result))
               }
             })
           }
<span class="co">// ...           </span></code></pre></div>
<p>Note that the call <code>clientsExecutionContext.execute</code> will create a thread from that execution context, setting free the thread that was evaluating the <code>IO</code> for-comprehension. If the thread pool used by the execution context can create new threads if no free ones are available, then we will be able to attend as many clients as needed. This is similar to the solution we used previously shifting the task to the execution context! And in fact <code>shift</code> makes something close to what we have just coded: it introduces asynchronous boundaries to reorganize how threads are used. The final result will be identical to our previous server version. To attend client connections, if no thread is available in the pool, new threads will be created in the pool. A full version of our echo server using this approach is <a href="https://github.com/lrodero/cats-effect-tutorial/blob/master/src/main/scala/catsEffectTutorial/EchoServerV5_Async.scala">available in github</a>.</p>
<h3 id="when-is-async-useful-then">When is <code>async</code> useful then?</h3>
<p>The <code>async</code> construct is useful specially when the task to run by the <code>IO</code> can be terminated by any thread. For example, calls to remote services are often modelled with <code>Future</code>s so they do not block the calling thread. When defining our <code>IO</code>, should we block on the <code>Future</code> waiting for the result? No! We can wrap the call in an <code>async</code> call like:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">import</span> cats.<span class="fu">effect</span>.<span class="fu">IO</span>
<span class="kw">import</span> scala.<span class="fu">concurrent</span>.<span class="fu">ExecutionContext</span>.<span class="fu">Implicits</span>.<span class="fu">global</span>
<span class="kw">import</span> scala.<span class="fu">concurrent</span>.<span class="fu">Future</span>
<span class="kw">import</span> scala.<span class="fu">util</span>._

<span class="kw">trait</span> Service { <span class="kw">def</span> <span class="fu">getSomething</span>(): Future[String] }
<span class="kw">def</span> service: Service = ???

IO.<span class="fu">async</span>[String]{ (cb: Either[Throwable, String] =&gt; Unit) =&gt; 
  service.<span class="fu">getSomething</span>().<span class="fu">onComplete</span> {
    <span class="kw">case</span> <span class="fu">Success</span>(s) =&gt; <span class="fu">cb</span>(<span class="fu">Right</span>(s))
    <span class="kw">case</span> <span class="fu">Failure</span>(e) =&gt; <span class="fu">cb</span>(<span class="fu">Left</span>(e))
  }
}</code></pre></div>
<p>So, our aim is to create an echo server that does not require a thread per connected socket to wait on the blocking <code>read()</code> method. If we use a network library that avoids or at limits blocking operations, we could then combine that with <code>async</code> to create such non-blocking server. And Java NIO can be helpful here. While Java NIO does have some blocking method (<code>Selector</code>'s <code>select()</code>), it allows to build servers that do not require a thread per connected client: <code>select()</code> will return those 'channels' (such as <code>SochetChannel</code>) that have data available to read from, then processing of the incoming data can be split among threads of a size-bounded pool. This way, a thread-per-client approach is not needed. Java NIO2 or netty could also be applicable to this scenario. We leave as a final exercise to implement again our echo server but this time using an async lib.</p>
<h2 id="conclusion">Conclusion</h2>
<p>With all this we have covered a good deal of what cats-effect has to offer (but not all!). Now you are ready to use to create code that operate side effects in a purely functional manner. Enjoy the ride!</p>
</body>
</html>
